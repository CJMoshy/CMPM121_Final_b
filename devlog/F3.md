## Devlog F2

### F0+F1+F2
No major changes were really made to the requirements and most of F3 was really just focused on the translation as well as UI changes. We added in a display of turns and levels for the game and we also reorganized the file structure a bit to also make the files feel less cluttered and organized. There was also the deployment of our website onto github pages and the addition of images to help the players visualize that the plants are growing as well. 

### Internationalization
We were able to distinguish between the strings internal to the program and the strings that would be shown to the player by having all .tsx that returned UI elements in the src/component folder. It made it extremely easy to just go into that folder and change all the return statements in the .tsx files as those where the only files that had any UI elements that needed to be translated. There's also a TranslateLanguage.ts that contains all the three languages that are being translated between. All the UI elements are just separated away with a .tsx and the logic is also separated away so none of our game logic ever touches a react component and the react component calls the game logic instead for the game to work. If we ever need to add additional support for a lanugage you would just go to TranslateLanguage.ts and edit the ```languageNames```, ```translationObject```, and ```getNumberTranslation``` where you have to add on an additional if statement and a string of the digits from 0 - 9 if the language has that system. Otherwise, it will be arabic numerals and the reasoning will be explained more in Localization with Chinese. 

### Localization
Tell us about which three languages your game supports. For each language, tell us about how you accomplished that localization. Did a team member use their own knowledge of the language? Did you have a friend, volunteer classmate, or paid expert help? Did you make use of a tool like ChatGPT to help? (If so, describe your prompts so that we can see how you gave the system extra context for your project.)

How should the user select which language will be used? Do they change the language setting from inside the game? Did you release three different versions of the game with a different language hard-coded into each? Does the player launch the game with special options (e.g. command line arguments or URL parameters) that encode the choice of language?
The three languages, that our game supports would be English, Chinese, and Farsi/Persian. Elton choose the languages and knows a little bit of Chinese but most of the translations were done with the help of Brace. The prompts were just to translate the words from English into Chinese or English into Farsi and some of the letters that couldn't be translated into Chinese or Farsi such as Cell i or j were instead converted into cell horizontal and cell vertical the prompt was "how would you translate Cell (insert letter) to (language to translate) if you can't use the english letter (insert letter)?". This was to ensure that it made more sense if the players didn't know too much english and would make more sense. However, most of the prompts were "what is (word to translate) in (language to translate)" and brace did most of the work. There was also the use of machine translation such as DeepL and Google translate as well to read out the words such as Chinese to see if it made more sense.  

For this second question about about how to select which language to use, we have a dropdown menu that the players can select to switch between the languages. The menu is in TranslateUI.tsx and that uses an object called translationObject that contains all of our three languages and their translations. It basically wraps around the languages which are also objects that have a word and then their translation. For english, it's a one to one mapping where a word like "Reap": "Reap". For Chinese, it's  "Reap": "收割" and Farsi, it's "Reap": "درو کردن". These objects just contain the strings that need to be translated and for numbers, it's a different function that's used to translate them. There is also an additional object that are the languageNames with a code, displayName, and an orientation for text which is currently unused. 
As this is react, we have a useContext called TranslateContext that is first set in TranslateUI. This context passes in ```{currentLanguage, setLanguage} = useContext(TranslateContext)``` and is used by all the other .tsx files in Components besides Rendering Engine.tsx. The currentLanguage is set in TranslateUI.tsx by a dropdown menu that calls on the languageNames object discussed above. It is exported as ```<Translator/ >``` and in App.tsx, this ```{currentLanguage, setLanguage}``` is then set to ```useState<string>("en")``` which makes the default state of the language to be english. 
This is where ``getStringTranslation(key: string, currentLanguage: string,)``` comes in. 
For this function, the currentLanguage is passed in and based on the currentLanguage, it passes the translation that comes from the language objects. For example, if I called ```getStringTranslation("Up", currentLanguage)``` and the currentLanguage is chinese, it will look for the object labled "cn". After that, it will then look for the word "Up" and if it matches, it returns the translation "上". Otherwise, it just returns back the string that was put in. If "arrow" was put in and there was no translation for it in the object, it just returns back "arrow". For our game, we just have all the words mapped and if had to change it, we would just add onto the translatonObject and add in the Chinese and Farsi as well as the one to one mapping in English. 
For numbers, it's a different case as we just decided to keep the arabic numerals for all the languages as it becomes increasing difficult to translate numbers as they gain a 0th place in Chinese and Farsi also just uses arabic numerals. 100 is a single character in Chinese (百) that can't be split into "1, 0, 0". So when we go to 2225, the translation is "二千二百二十五" which is the same as writing "twenty thousand two hundred twenty five". Because of this, you would have to hardcode a prefix each time which is difficult to do especially for a number such as a turn or level which could be possibly infinite. To keep it more dynamic, we just decided to keep the numerals just the same and not do any translation of them. 

### Mobile Installation
We used Github Actions with vite to do our continous deployment, and turned it into a PWA to make the game installable on desktop and mobile devices. The changes made in order to the game installable was the addition of a ```manifest.json``` file, as well as a ```service worker.ts``` to make the app usable while offline. No other major changes were made to make the game installable, but we did make some small changes to our design and codebade outside of the PWA. MDN Web Docs was a very helpful resource in our understanding of how PWAs worked, and we used some of the code from their tutorial with js13kGames for this game. 
A link the the tutorial for the PWA: https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Tutorials/js13kGames

### Mobile Play (Offline)
There weren't any major changes to our design to make sure that it worked in the offline case as we already had that planned out with our react layout. We already had buttons for the layout and thought about how it would work for a phone already. Our game doesn't have any geolocation or anything that require online services, so the implementation of offline play was fairly smooth. The only changes were the addition of the aforementioned ```manifest.json``` and ```ServiceWorker.ts```.

## Reflection
Looking back on how you achieved the new F3 requirements, how has your team’s plan changed? Did you reconsider any of the choices you previously described for Tools and Materials or your Roles? Has your game design evolved now that you've started to think about giving the player more feedback? It would be very suspicious if you didn’t need to change anything. There’s learning value in you documenting how your team’s thinking has changed over time.

For our plans, we did shift more towards the UI aspect of the game with the F3 requirements as we had the time to do so and we wanted users to have a better experience. Our plan was to meet the requirements with more of a focus on visuals this time around without compromising on the strong code base that we already built. The game has changed to have a current turn and a current level in our display to help out players as well as the addition of images to help the player visualize the game more instead of just staring at the numbers at the bottom of the screen. We are now looking to do more UI style changes with CSS and to make it look better as we get better with React and using it. 