## Devlog F2

### F0+F1+F2
No major changes were really made to the requirements and most of F3 was really just focused on the translation as well as UI changes. We added in a display of turns and levels for the game and we also reorganized the file structure a bit to also make the files feel less cluttered and organized. There was also the deployment of our website onto github pages and the addition of images to help the players visualize that the plants are growing as well. 

### Internationalization

The devlog should explain how your code has changed to distinguish between strings internal to the program and strings that will be shown to the player (needing localization). If you did something clever with your language's type system so that the compiler helps you catch incomplete translations or other missing messages, brag about that in this section.

This section should outline which code or data files need to get changed when adding support for a new language or adding a new translatable message to the game.

For this part, we have a translationObject that contains all of our three languages: English, Chinese (Logographic), and Persian/Farsi (RTL) and their translations. It basically wraps around the languages which are also objects that have a word and then their translation. For english, it's a one to one mapping where a word like "Reap": "Reap". For Chinese, it's  "Reap": "收割" and Farsi, it's "Reap": "درو کردن". These objects just contain the strings that need to be translated and for numbers, it's a different function that's used to translate them. There is also an additional object that are the languageNames with a code, displayName, and an orientation for text which is currently unused. 
As this is react, we have a file in the component folder called TranslateUI.tsx that has ```{currentLanguage, setLanguage} = useContext(TranslateContext)```. This creates a currentLanguage that can be called on and also set as well which is what we do in TranslateUI.tsx with a function. This function uses the languageNames object and when we change the language via a dropdown menu, the language code changes as well as the name displayed on the dropdown. This ```{currentLanguage, setLanguage}``` is then set to ```useState<string>("en")``` which makes the default state of the language to be english. This is then exported as ```<Translator/ >``` and is then added in to the return of APP.tsx. Because of this, the currentLanguage is now a state that is accessible to all the UI components and is a string that can be changed to translate all of the elements.
This is where the functions called ```getStringTranslation(key: string, currentLanguage: string,)``` and ```getNumberTranslation(numberToTranslate: number, currentLanguage: string,)``` come in. 
For strings, the currentLanguage is passed in and based on the currentLanguage, it passes the translation that comes from the language objects. For example, if I called ```getStringTranslation("Up", currentLanguage)``` and the currentLanguage is chinese, it will look for the object labled "cn". After that, it will then look for the word "Up" and if it matches, it returns the translation "上". Otherwise, it just returns back the string that was put in. If "arrow" was put in and there was no translation for it in the object, it just returns back "arrow". For our game, we just have all the words mapped and if had to change it, we would just add onto the translatonObject and add in the Chinese and Farsi as well as the one to one mapping in English. 
For numbers, it's a different case as we just decided to keep the arabic numerals for both chinese and english as it becomes increasing difficult to translate numbers as they gain a 0th place. For example, the number "100" can't just be split into "1, 0, 0" and be translated that way in Chinese. It's not "一, 零, 零" and it's "百". The "0, 1" or "1, 0, 1" is still "零, 一" but the suffix changes. If we go to a number like "2225", it becomes "二千二百二十五" where "二千" is 2000 and "二百" is 200 and "二十" is 20 and "五" is 5. Because of this, it becomes a nightmare to try to translate numbers into chinese and you would have to hardcode a prefix each time which is extremely difficult to do especially for a number such as a turn or level which could be possibly infinite. To keep it more dynamic, we decided to do that and only decided to change the numerals for Farsi as they have digit system more in line with arabic numerals and  ```getNumberTranslation(numberToTranslate: number, currentLanguage: string,)``` just takes in a number and turns the digits into strings and then turns the string back into a number to be returned. 

### Localization

Tell us about which three languages your game supports. For each language, tell us about how you accomplished that localization. Did a team member use their own knowledge of the language? Did you have a friend, volunteer classmate, or paid expert help? Did you make use of a tool like ChatGPT to help? (If so, describe your prompts so that we can see how you gave the system extra context for your project.)

How should the user select which language will be used? Do they change the language setting from inside the game? Did you release three different versions of the game with a different language hard-coded into each? Does the player launch the game with special options (e.g. command line arguments or URL parameters) that encode the choice of language?

### Mobile Installation

How did you get your game to be installable on a smartphone-class mobile device? If you followed a tutorial, guide, video, or blogpost, directly link to those resources that helped you learn. What changes were needed to make the game installable?

### Mobile Play (Offline)

What changes to your design were needed to make it play well on a mobile device? Were there any changes needed to make sure it worked in the offline case?

## Reflection
Looking back on how you achieved the new F3 requirements, how has your team’s plan changed? Did you reconsider any of the choices you previously described for Tools and Materials or your Roles? Has your game design evolved now that you've started to think about giving the player more feedback? It would be very suspicious if you didn’t need to change anything. There’s learning value in you documenting how your team’s thinking has changed over time.